# Module 9: MPC 与 门限签名 (Threshold Signature) 原理与实战

> **警告**: 本文档涉及密码学核心概念。在生产环境中使用任何自研密码学代码由其危险，请务必使用经过审计的开源库。

---

## 第一部分：核心概念 (Theory)

### 1.1 什么是 MPC (Multi-Party Computation)？

**安全多方计算 (MPC)** 是一种密码学协议，允许多个参与方在**不泄露各自隐私输入**的前提下，共同计算一个函数的结果。

在区块链钱包场景下，MPC 主要用于 **私钥分片与协同签名**。

### 1.2 SSS vs TSS：容易混淆的概念

很多时候我们提到的 "多签" 或 "MPC"，实际上混淆了两个概念：

| 特性             | SSS (Shamir's Secret Sharing)                                                      | TSS (Threshold Signature Scheme)                               |
| :--------------- | :--------------------------------------------------------------------------------- | :------------------------------------------------------------- |
| **私钥存在形式** | 私钥被切分为 N 个碎片 (Shares)。                                                   | 私钥**从未完整出现过** (KeyGen 阶段就是分布式的)。             |
| **签名过程**     | **必须重构私钥**：收集 M 个碎片 -> 还原私钥 -> 签名 -> 销毁私钥。                  | **无需重构私钥**：各方分别用碎片计算中间值 -> 聚合出最终签名。 |
| **单点故障风险** | **高**：重构私钥的机器 (Coordinator) 是绝对的单点故障 (SPOF)。一旦被骇，私钥泄露。 | **低**：私钥从未在任何一台机器的内存中完整存在过。             |
| **实现难度**     | 中等 (多项式插值)。                                                                | 极高 (由于零知识证明和同态加密)。                              |
| **典型应用**     | Hashicorp Vault Unseal, 密钥冷备份。                                               | Fireblocks, ZenGo, Coinbase Wallet。                           |

> **本次 Demo 目标**: 由于 TSS 实现及其复杂（通常涉及 P2P 网络和几万行代码），我们将实现 **SSS (Shamir's Secret Sharing)** 作为概念验证，展示 "密钥分片" 的数学魅力。

---

## 第二部分：数学原理 (The Math)

SSS 的核心是 **拉格朗日插值法 (Lagrange Interpolation)**。

1.  **构造多项式**:
    为了保护一个秘密 $S$（即私钥），我们构造一个 $M-1$ 次多项式 $f(x)$，使得 $f(0) = S$。
    $$ f(x) = a*0 + a_1x + a_2x^2 + ... + a*{M-1}x^{M-1} $$
    其中 $a_0 = S$，其他系数 $a_1...a_{M-1}$ 是随机生成的。

2.  **生成碎片 (Share)**:
    我们计算 $N$ 个点：$(1, f(1)), (2, f(2)), ..., (N, f(N))$。
    每个点就是一个碎片，分发给不同的管理员。

3.  **重构秘密 (Recover)**:
    几何学告诉我们：**两点确定一条直线 (1次)，三点确定一条抛物线 (2次)**。
    只要我们拥有圆弧上的 $M$ 个点，就能唯一确定这个 $M-1$ 次多项式 $f(x)$。
    一旦确定了函数，我们代入 $x=0$，就得到了 $f(0) = S$ (私钥)。

---

## 第三部分：实战指南 (Practice)

我们将使用 Go 语言实现一个 CLI 工具，演示私钥的 "碎尸万段" 与 "起死回生"。

### 3.1 依赖库

为了不写出有漏洞的代码，我们使用业界标准库：
`github.com/hashicorp/vault/shamir`

### 3.2 功能设计

我们需要在 `wallet-cli` 中增加 `mpc` 子命令：

1.  **Split (分片)**:
    - Input: 私钥 (Hex)
    - Params: N (Total), M (Threshold)
    - Output: N 行 Hex 字符串 (Shares)

2.  **Recover (恢复)**:
    - Input: M 个 Shares (Hex)
    - Output: 原始私钥

### 3.3 核心代码预览

```go
// Split
shares, err := shamir.Split(secretBytes, N, M)

// Combine
secret, err := shamir.Combine(shares)
```

是不是看起来很简单？但背后的 GF(2^8) 有限域运算逻辑已经被库封装好了。如果自己写，很容易因为侧信道攻击 (Side-Channel Attack) 导致私钥泄露。

---

## 第四部分：安全警告 (Critical Security Notes)

1.  **内存清理**: 在 Golang 中，`[]byte` 会在内存中驻留直到 GC。处理私钥后，应该手动用 `0` 覆盖内存（尽管 Go 的 GC 机制让这很难做到完美，但态度要有）。
2.  **Coordinator 风险**: 执行 `Recover` 的这台机器，必须是 **离线** 且 **绝对安全** 的。一旦它联网且有木马，瞬间私钥就被窃取了。
    - _这也是为什么 TSS 优于 SSS 的原因：TSS 不需要这台危险的 Coordinator。_

---
